<html>

<!-- Load d3.js -->
<script src='https://d3js.org/d3.v5.min.js'></script>

<style>
    #tooltip {
        opacity: 0;
        position: absolute;
        text-align: left;
        width: 145px;
        height: 90px;
        background: white;
        border: 0px;
    }

    ul {
        list-style-type: none;
        margin: 0;
        padding: 0;
    }
</style>


<body onload='init()'>

    <!-- Create a div where the graph will take place -->
    <!--<svg class ="circle"></svg>-->
    <button id="scene1">scene1</button>
    <button id="scene2">scene2</button>

    <div id="tooltip"></div>
    <div id="title"></div>

    <p>In this example, we remove the bullets from the list, and its default padding and margin.</p>

    <ul>
        <li><a href="#scene1">Scene1</a></li>
        <li><a href="#scene2">Scene2</a></li>
        <li><a href="#scene3">Scene3</a></li>
        <li><a href="#scene4">Scene4</a></li>
    </ul>

    <script>

        var scene, scene1, scene2

        //$("#scene2").click(function () {
        //    scene = scene2
        //})
        //$("#scene1").click(function () {
        //    scene = scene1
        //})

        async function init() {

            // set the dimensions and margins of the graph
            var margin = { top: 10, right: 30, bottom: 40, left: 60 },
                width = 600 - margin.right - margin.left,
                height = 600 - margin.top - margin.bottom;

            // append the svg to the body
            var svg = d3.select("#title")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

            // read the data
            const data = await d3.csv('https://raw.githubusercontent.com/jarosales1029/NarrativeViz.github.io/main/cars2017.csv')

            // xScale logarithmic
            var logX = d3.scaleLog()
                .domain([10, 10])
                .range([0, width + 20])
                .base(10);

            // yScale logarithmic
            var logY = d3.scaleLog()
                .domain([10, 150])
                .range([height, 0])
                .base(10);

            // xAxis
            var xAxis = svg.append("g")
                .attr("class", "xAxis")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(logX)
                    .tickValues([10, 20, 50, 100, 150])
                    .tickFormat(d3.format("~s")));

            // yAxis
            var yAxis = svg.append("g")
                .attr("class", "yAxis")
                //.attr("transform","translate("+margin+","+margin/2+")")
                .call(d3.axisLeft(logY)
                    .tickValues([10, 20, 50, 100, 150])
                    .tickFormat(d3.format("~s")));

            // xAxis label
            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("x", width / 2 + margin.right)
                .attr("y", height + (+margin.right + 5))
                .text("Average City MPG")

            // yAxis label
            svg.append("text")
                .attr("text-anchor", "middle")
                .attr("transform", "rotate(-90)")
                .attr("y", -margin.left + 20)
                .attr("x", -height / 2)
                .text("Average Highway MPG")

            // add a clipPath: everything out of this area won't be drawn.
            var clip = svg.append("defs").append("svg:clipPath")
                .attr("id", "clip")
                .append("svg:rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x", 0)
                .attr("y", 0);

            // radius value
            var rValue = function (d) { return parseInt(d.EngineCylinders) + 6; }

            // engine cylinders variable
            var cylinder_color = function (d) { return color(d.EngineCylinders) }

            // color scale: give me the EngineCylinders value, I return a color
            var color = d3.scaleOrdinal()
                .domain(cylinder_color)
                .range(["purple", "orange", "green", "steelblue"]);

            // tooltip var
            var tooltip = d3.select("#tooltip")
                .style("opacity", 0)
                .attr("class", "tooltip")
                .style("background-color", "white")
                .style("border", "solid")
                .style("border-width", "2px")
                .style("border-radius", "5px")
                .style("padding", "5px");

            // set the zoom and Pan features: how much you can zoom, on which part, and what to do when there is a zoom
            var zoom = d3.zoom()
                .scaleExtent([.5, 20])  // This control how much you can unzoom (x0.5) and zoom (x20)
                .extent([[0, 0], [width, height]])
                .on("zoom", updateChart);

            // this add an invisible rect on top of the chart area. This rect can recover pointer events: necessary to understand when the user zoom
            svg.append("rect")
                .style("opacity", 0)
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
                .call(zoom);
            // now the user can zoom and it will trigger the function called updateChart

            //console.log(selected_cylinder)

            // filter
            //var filter = scatter.filter(function (d) { return !d.children; }).append("circle")
            //    .attr("r", function (d) { return d.r; })

            // on click function
            //var onClick = function (d) {

            //    var obj1 = d3.select(this).attr("class")

            //    console.log(obj1)

            //d3.selectAll(obj1)
            //    .transition()
            //    .duration(300)
            //    .style('stroke', 'black')
            //    .style("opacity", 1)
            //    .style("fill", cylinder_color)
            //    .attr("r", 5)

            //d3.selectAll(".circle")
            //    .transition()
            //    .duration(300)
            //    .style("fill", "lightgrey")
            //    .attr("r", 3)
            //}

            // create mouseleave function
            var mouseLeave = function () {
                d3.selectAll(".circle")
                    .transition()
                    .duration(300)
                    .attr('r', rValue)
                    .style("fill", cylinder_color)
                    .style("stroke", "none")
                    .style("opacity", .7)
            }

            // create mouseover function
            var mouseOver = function (d, i) {

                d3.selectAll(".circle")
                    .transition()
                    .duration(300)
                    .style("fill", "lightgrey")
                    .attr("r", 4)
                d3.select(this)
                    .transition()
                    .duration(300)
                    .style('stroke', 'black')
                    .style("opacity", 1)
                    .style("fill", cylinder_color)
                    .attr("r", 2.5)
                tooltip.style("opacity", .8)
                    .style("left", (d3.event.pageX) + 50 + "px")
                    .style("top", (d3.event.pageY) + "px")
                    .html(d.Make + '<br/> Fuel: ' + d.Fuel + '<br/> Cylinders: ' + d.EngineCylinders + '<br/> City: ' + d.AverageCityMPG + '<br/> Highway: ' + d.AverageHighwayMPG);
            }

            // create circles with xAxis at [10, 10]
            var scatter = svg.append('g')
                .attr("clip-path", "url(#clip)")
                .selectAll(".circle")
                .data(data)
                .enter()
                .append("circle")
                .attr("class", function (d) { return "circle " + d.EngineCylinders })
                .attr("cx", function (d) { return logX(d.AverageCityMPG); })
                .attr("cy", function (d) { return logY(d.AverageHighwayMPG); })
                .attr("r", rValue)
                .style("opacity", .4)
                .style("fill", cylinder_color)
                //    .on("click", onClick)
                .on("mouseleave", mouseLeave)
                .on("mouseover", mouseOver)
                .on("mouseout", function () { tooltip.style("opacity", 0) });

            // changing the logX domain to setup for the transition
            logX.domain([10, 150])
            svg.select(".xAxis")
                //.attr("opacity", "1")
                .call(d3.axisBottom(logX)
                    .tickValues([10, 20, 50, 100, 150])
                    .tickFormat(d3.format("~s")));

            // plot circles with new xAxis domain of [10, 150]
            scatter
                .transition("fillColor")
                .delay(function (d, i) { return (i * 3) })
                .duration(1337)
                .attr("cx", function (d) { return logX(d.AverageCityMPG); })
                .attr("cy", function (d) { return logY(d.AverageHighwayMPG); });


            // A function that updates the chart when new boundaries are available after zoom
            function updateChart() {

                // recover the new scale
                var newX = d3.event.transform.rescaleX(logX);
                var newY = d3.event.transform.rescaleY(logY);

                // update axes with these new boundaries
                xAxis.call(d3.axisBottom(newX)
                    .tickValues([10, 20, 50, 100, 150])
                    .tickFormat(d3.format("~s")))
                yAxis.call(d3.axisLeft(newY)
                    .tickValues([10, 20, 50, 100, 150])
                    .tickFormat(d3.format("~s")))

                // plot circles with new xAxis
                scatter
                    .transition("fillColor")
                    .delay(function (d, i) { return (i * 3) })
                    .duration(1337)
                    .attr("cx", function (d) { return newX(d.AverageCityMPG); })
                    .attr("cy", function (d) { return newY(d.AverageHighwayMPG); });
            }
            // Insert the zoom rect *before* the circles, so the circles
            // are drawn in front of the recrt
            focus.insert("rect", "circle")
                .attr("class", "zoom")
                .attr("width", width)
                .attr("height", height)
                .call(zoom);
        }
    </script>
</body>

</html>
